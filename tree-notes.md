# A Note on Merkle Tree Ordering

The "natural" ordering for a binary tree orders its leaves sequentially from left to right.
The leftmost node has index 0; every bit of its index is 0.
In a natural Merkle tree, the path up from index 0 should always find its siblings on the **right**.

As we follow the path from a leaf to the root, a Merkle tree can have either a “natural order” or a “mirrored order:”

| Index Bit | Natural Order            | Mirrored Order           |
|:----------|:-------------------------|:-------------------------|
| 0 (Even)  | `Hash(Current, Sibling)` | `Hash(Sibling, Current)` |
| 1 (Odd)   | `Hash(Sibling, Current)` | `Hash(Current, Sibling)` |

### 1. The Google Specification (Pseudo-code)

The [Google specification](https://roughtime.googlesource.com/roughtime/+/HEAD/PROTOCOL.md#authenticating-replies) calls for a natural tree:

```c
while len(path) > 0 {
  if index&1 == 0 { // index even
    hash = hashNode(hash, path[:64]) // sibling on right
  } else {          // index odd
    hash = hashNode(path[:64], hash) // sibling on left
  }

  index >>= 1
  path = path[64:]
}
```

Here we see that if the index is even, the sibling is on the right.
This is natural ordering.

### 2. Google's C++ Implementation

The C++ reference implementation appears to be internally inconsistent.

#### **Server code ([server.cc](https://roughtime.googlesource.com/roughtime/+/refs/heads/master/server.cc)):**

The server implements a **natural** tree.
If the index is even, the sibling is fetched from index \+ 1 (the right).

```c
void Tree::GetPath(uint8_t *out_path, size_t index) {

  for (size_t level = 0; level < levels_ - 1; level++) {
    if (index % 2 == 1) { // index is odd
      memcpy(out_path, tree_[level][index - 1], kNonceLength); // sibling on left
    } else {             // index is even
      memcpy(out_path, tree_[level][index + 1], kNonceLength); // sibling on right
    }
    out_path += kNonceLength;
    index /= 2;
  }
  ROUGHTIME_DCHECK_EQ(0ul, index);
}
```

#### Client code ([client.cc](https://roughtime.googlesource.com/roughtime/+/refs/heads/master/client.cc)):

However, the client code which validates responses appears to assume a mirrored tree:

```c
    const bool path_element_is_right = tree_index & 1; // index is odd
    if (path_element_is_right) { // index is odd
      HashNode(hash, hash, path + i);  // sibling on right
    } else {                     // index is even
      HashNode(hash, path + i, hash);  // sibling on left
    }
```

Here we see that if the index is even, the sibling is assumed to be on the **left**.
That's opposite to natural ordering, or **mirrored** ordering.

#### Client test ([client\_test.cc](https://roughtime.googlesource.com/roughtime/+/refs/heads/master/client_test.cc)):

To make the client pass, the test utility also implements a **mirrored** tree.

```c
void ResponseBuilder::MakeTree(uint32_t i) {
  tree_index = i;
  HashLeaf(tree_root, nonce);
  for (tree_path_len = 0; i > 0; i >>= 1) {
    const bool path_element_is_right = i & 1; // index is odd
    uint8_t* sibling = tree_path + tree_path_len;
    RAND_bytes(sibling, kNonceLength);
    if (path_element_is_right) {  // index is odd
      HashNode(tree_root, tree_root, sibling); // sibling on right
    } else {                      // index is even
      HashNode(tree_root, sibling, tree_root); // sibling on left
    }
    tree_path_len += kNonceLength;
  }
}
```

The test does not appear to use data generated by the server.

### 3. The IETF Specification

The [IETF spec](https://www.ietf.org/archive/id/draft-ietf-ntp-roughtime-15.html#name-the-merkle-tree) appears to contain a contradiction.
It first calls for natural ordering:

```
"Leaf nodes are indexed left to right, beginning with zero."
```

But the provided verification algorithm described in the following section is explicitly **mirrored**:

```
If the current bit in INDX is 0 then h = H(0x01 || node || hash)
```

*(Here node is the sibling, placed at the first/left position for an even index).*

## Conclusion

While the prose in the documents often suggests a "natural" order, both the **verification logic** in the Google client and the IETF algorithm utilize the **mirrored** approach.
Cloudflare's implementations appears to use the "natural" order.

It's therefore somewhat unclear which ordering one should actually use to implement the protocol.
This library follows the description (but not the algorithm) detailed in the protocol document, along with the Cloudflare implementation, and writes trees using the natural ordering.
However, it exposes a parameter `:tree-order` which can be override this default.

<!-- Local Variables: -->
<!-- fill-column: 1000000 -->
<!-- End: -->
